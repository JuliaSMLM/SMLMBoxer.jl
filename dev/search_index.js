var documenterSearchIndex = {"docs":
[{"location":"#SMLMBoxer","page":"Home","title":"SMLMBoxer","text":"Documentation for SMLMBoxer.\n\n","category":"section"},{"location":"#SMLMBoxer._getboxes_impl-Tuple{SMLMBoxer.GetBoxesArgs}","page":"Home","title":"SMLMBoxer._getboxes_impl","text":"_getboxes_impl(args::GetBoxesArgs)\n\nInternal implementation of getboxes that does the actual work.\n\n\n\n\n\n","category":"method"},{"location":"#SMLMBoxer.convolve-Tuple{AbstractArray{<:Real}, Matrix{Float32}}","page":"Home","title":"SMLMBoxer.convolve","text":"convolve(imagestack, kernel; use_gpu=false)\n\nConvolve imagestack with given kernel.\n\nArguments\n\nimagestack: Input array of image data\nkernel: Kernel to convolve with \n\nKeyword Arguments\n\nuse_gpu: Whether to use GPU \n\nReturns\n\nfiltered_stack: Convolved image stack\n\n\n\n\n\n","category":"method"},{"location":"#SMLMBoxer.convolve_variance_weighted-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractMatrix{T}, Float32, Bool}} where T<:Real","page":"Home","title":"SMLMBoxer.convolve_variance_weighted","text":"convolve_variance_weighted(imagestack, variance_map, sigma, use_gpu)\n\nApply variance-weighted Gaussian convolution using KernelAbstractions. Device-agnostic: works on CPU and GPU with same code.\n\nArguments\n\nimagestack: Input image (rows, cols, 1, frames)\nvariance_map: Variance at each pixel (rows, cols)\nsigma: Gaussian sigma\nuse_gpu: Use GPU if available\n\nReturns\n\nVariance-weighted filtered image\n\n\n\n\n\n","category":"method"},{"location":"#SMLMBoxer.dog_filter-Tuple{AbstractArray{<:Real}, SMLMBoxer.GetBoxesArgs}","page":"Home","title":"SMLMBoxer.dog_filter","text":"dog_filter(imagestack, args)\n\nApply DoG filter to imagestack based on args. Uses variance-weighted filtering if sCMOS camera is provided.\n\nArguments\n\nimagestack: Input array of image data\nargs: Arguments with sigma values and camera\n\nReturns\n\nfiltered_stack: Filtered image stack\n\n\n\n\n\n","category":"method"},{"location":"#SMLMBoxer.dog_filter_variance_weighted-Tuple{AbstractArray{<:Real}, Real, Real, SMLMBoxer.GetBoxesArgs}","page":"Home","title":"SMLMBoxer.dog_filter_variance_weighted","text":"dog_filter_variance_weighted(imagestack, sigma_small, sigma_large, args)\n\nApply variance-weighted DoG filter using sCMOS variance map. Implements SMITE-style inverse variance weighting during convolution.\n\nArguments\n\nimagestack: Input image data (rows, cols, 1, frames)\nsigma_small: Sigma for small Gaussian\nsigma_large: Sigma for large Gaussian\nargs: GetBoxesArgs with camera\n\nReturns\n\nfiltered_stack: Variance-weighted filtered image\n\n\n\n\n\n","category":"method"},{"location":"#SMLMBoxer.dog_kernel-Tuple{Float32, Float32}","page":"Home","title":"SMLMBoxer.dog_kernel","text":"dog_kernel(s1, s2)\n\nCompute difference of Gaussian kernels.   \n\nArguments\n\nsigma_small: Sigma for small Gaussian \nsigma_large: Sigma for large Gaussian\n\nReturns\n\ndog: Difference of Gaussians kernel\n\n\n\n\n\n","category":"method"},{"location":"#SMLMBoxer.extract_camera_roi-Union{Tuple{T}, Tuple{SMLMData.IdealCamera{T}, Any, Any}} where T","page":"Home","title":"SMLMBoxer.extract_camera_roi","text":"extract_camera_roi(camera::AbstractCamera, row_range, col_range)\n\nExtract a camera ROI with calibration data for the specified pixel region.\n\nArguments\n\ncamera: Source camera object\nrow_range: Range of rows to extract\ncol_range: Range of columns to extract\n\nReturns\n\nCamera object of the same type with ROI calibration data\n\n\n\n\n\n","category":"method"},{"location":"#SMLMBoxer.fillbox!-Tuple{AbstractMatrix{<:Real}, AbstractArray{<:Real, 4}, Vararg{Int64, 4}}","page":"Home","title":"SMLMBoxer.fillbox!","text":"fillbox!(box, imagestack, row, col, im, boxsize)\n\nFill a box with a crop from the imagestack.\n\nArguments\n\nbox: Array to fill with box crop\nimagestack: Input image stack \nrow, col, im: Coords for crop\nboxsize: Size of box\n\nReturns\n\nboxcoords: Upper Left corners of boxes N x (row, col, im)\n\n\n\n\n\n","category":"method"},{"location":"#SMLMBoxer.findlocalmax-Tuple{AbstractArray{<:Real}, Int64}","page":"Home","title":"SMLMBoxer.findlocalmax","text":"findlocalmax(imagestack, kernelsize; minval=0.0, use_gpu=false)\n\nFind the coordinates of local maxima in an image.\n\nArguments\n\nimagestack: An array of real numbers representing the image data.\nkernelsize: The size of the kernel used to identify local maxima.\n\nKeyword Arguments\n\nminval: The minimum value a local maximum must have to be considered valid (default: 0.0).\nuse_gpu: Whether or not to use GPU acceleration (default: false).\n\nReturns\n\ncoords: The coordinates of the local maxima in the image.\n\n\n\n\n\n","category":"method"},{"location":"#SMLMBoxer.gaussian_2d-Tuple{Float32, Int64}","page":"Home","title":"SMLMBoxer.gaussian_2d","text":"gaussian_2d(sigma, ksize)\n\nCreate a 2D Gaussian kernel.\n\nArguments\n\nsigma: Standard deviation\nkernelsize: Kernel size\n\nReturns\n\nkernel: Normalized 2D Gaussian kernel  \n\n\n\n\n\n","category":"method"},{"location":"#SMLMBoxer.genlocalmaximage-Tuple{AbstractArray{<:Real}, Int64}","page":"Home","title":"SMLMBoxer.genlocalmaximage","text":"genlocalmaximage(imagestack, kernelsize; minval=0.0, use_gpu=false)\n\nGenerate an image highlighting the local maxima.\n\nArguments\n\nimagestack: An array of real numbers representing the image data.\nkernelsize: The size of the kernel used to identify local maxima.\n\nKeyword Arguments\n\nminval: The minimum value a local maximum must have to be considered valid (default: 0.0).\nuse_gpu: Whether or not to use GPU acceleration (default: false).\n\nReturns\n\nlocalmaximage: An image with local maxima highlighted.\n\n\n\n\n\n","category":"method"},{"location":"#SMLMBoxer.get_variance_map-Union{Tuple{T}, Tuple{SMLMData.IdealCamera{T}, Tuple{Int64, Int64}}} where T","page":"Home","title":"SMLMBoxer.get_variance_map","text":"get_variance_map(camera::AbstractCamera, imagesize)\n\nCompute variance map from camera calibration.\n\nArguments\n\ncamera: Camera object with noise calibration\nimagesize: Tuple of (nrows, ncols) for the image\n\nReturns\n\nVariance map (variance = readnoise²) matching image dimensions\n\n\n\n\n\n","category":"method"},{"location":"#SMLMBoxer.getboxes","page":"Home","title":"SMLMBoxer.getboxes","text":"getboxes(imagestack, camera=nothing; kwargs...)\n\nDetect particles/blobs in a multidimensional image stack and return coordinates and boxed regions centered around local maxima.\n\nArguments\n\nimagestack::AbstractArray{<:Real}: The input image stack. Should be 2D or 3D.\ncamera::Union{AbstractCamera,Nothing}: Optional camera object (IdealCamera or SCMOSCamera) from SMLMData. If provided, enables micron coordinate conversion and camera ROI extraction.\nboxsize::Int: Size of the box to cut out around each local maximum (pixels).\noverlap::Real: Amount of overlap allowed between boxes (pixels).\nsigma_small::Real: Sigma for small Gaussian blur kernel (pixels).\nsigma_large::Real: Sigma for large Gaussian blur kernel (pixels).\nminval::Real: Minimum value to consider as a local maximum.\nuse_gpu::Bool: Perform convolution and local max finding on GPU.\n\nReturns\n\nA NamedTuple with the following fields:\n\nboxes: Array with dimensions (boxsize, boxsize, nboxes) containing image patches\ncoords_pixels: N×3 matrix of detection centers (row, col, frame) in pixels\ncoords_microns: N×2 matrix of detection centers (x, y) in microns (only if camera provided)\nboxcoords: N×3 matrix of box upper-left corners (row, col, frame) in pixels\ncamera_rois: Vector of camera ROIs for each box (only if camera provided)\nmetadata: Additional information (number of detections, etc.)\n\nDetails on filtering\n\nThe image stack is convolved with a difference of Gaussians (DoG) filter to identify blobs and local maxima. The DoG is computed from two Gaussian kernels with standard deviations sigma_small and sigma_large.\n\nVariance-Weighted Filtering (sCMOS)\n\nWhen an SCMOSCamera is provided, the package uses variance-weighted filtering based on the SMITE algorithm. Each pixel's contribution to the convolution is weighted by:\n\nweight = gaussian_kernel / variance\n\nwhere variance = readnoise². This implements optimal inverse variance weighting:\n\nLow-noise pixels receive high weight (strong influence on detection)\nHigh-noise pixels receive low weight (reduced influence, avoiding false positives)\n\nThis significantly improves detection sensitivity in sCMOS data with spatially-varying noise.\n\nGPU Acceleration: Variance-weighted filtering uses KernelAbstractions.jl for device-agnostic computation. The same kernel code runs on both CPU and GPU, automatically selected based on use_gpu. This provides GPU acceleration for sCMOS cameras (10-100x speedup on large images).\n\nStandard Filtering (IdealCamera or no camera)\n\nStandard DoG convolution is used when no camera is provided or with IdealCamera. The convolution is performed via Flux/cuDNN on GPU or CPU, depending on use_gpu.\n\nAfter filtering, local maxima above minval are identified. Boxes are cut out around each maximum, excluding overlaps.\n\nExamples\n\n# Without camera\nresult = getboxes(imagestack; boxsize=7, overlap=2.0, sigma_small=1.0, sigma_large=2.0)\nboxes = result.boxes\ncoords = result.coords_pixels\n\n# With camera (enables micron coordinates and camera ROIs)\ncamera = IdealCamera(1:256, 1:256, 0.1f0)  # npixels_x, npixels_y, pixel_size\nresult = getboxes(imagestack, camera; boxsize=7, overlap=2.0)\nboxes = result.boxes\ncoords_microns = result.coords_microns\ncamera_rois = result.camera_rois\n\n\n\n\n\n","category":"function"},{"location":"#SMLMBoxer.getboxstack-Tuple{Any, Any, SMLMBoxer.GetBoxesArgs}","page":"Home","title":"SMLMBoxer.getboxstack","text":"getboxstack(imagestack, coords, args::GetBoxesArgs)\n\nCut out box regions from imagestack centered on coords.\n\nArguments\n\nimagestack: Input image stack\ncoords: Coords of box centers\nargs: Parameters\n\nReturns\n\nboxstack: Array with box crops from imagestack\nboxcoords: Upper left corners of boxes\ncamera_rois: Camera ROIs for each box (if camera provided)\n\n\n\n\n\n","category":"method"},{"location":"#SMLMBoxer.maxima2coords-Tuple{AbstractArray{Float32}}","page":"Home","title":"SMLMBoxer.maxima2coords","text":"maxima2coords(imagestack)\n\nGet coordinates of all non-zero pixels in input stack \n\nArguments\n\nimagestack: Input image stack\n\nReturns\n\ncoords: List of coords for each frame\n\n\n\n\n\n","category":"method"},{"location":"#SMLMBoxer.pixels_to_microns-Tuple{AbstractMatrix, SMLMData.AbstractCamera}","page":"Home","title":"SMLMBoxer.pixels_to_microns","text":"pixels_to_microns(pixel_coords, camera::AbstractCamera)\n\nConvert pixel coordinates (row, col) to micron coordinates (x, y) using camera geometry.\n\nArguments\n\npixel_coords: N×2 matrix of (row, col) coordinates\ncamera: Camera object with pixeledgesx and pixeledgesy\n\nReturns\n\nN×2 matrix of (x, y) coordinates in microns\n\n\n\n\n\n","category":"method"},{"location":"#SMLMBoxer.removeoverlap-Tuple{Vector{Matrix{Float32}}, SMLMBoxer.GetBoxesArgs}","page":"Home","title":"SMLMBoxer.removeoverlap","text":"removeoverlap(coords, args)\n\nRemove overlapping coords based on distance.\n\nArguments\n\ncoords: List of coords\nargs: Parameters  \n\nReturns\n\ncoords: Coords with overlaps removed \n\n\n\n\n\n","category":"method"},{"location":"#SMLMBoxer.reshape_for_flux-Tuple{AbstractArray{<:Real}}","page":"Home","title":"SMLMBoxer.reshape_for_flux","text":"reshapeforflux(arr::AbstractArray)\n\nReshape array to have singleton dims for Flux.jl convolution.  \n\nArguments\n\narr: Input array, must be 2D or 3D\n\nReturns\n\nReshaped array with added singleton dimensions\n\n\n\n\n\n","category":"method"},{"location":"#SMLMBoxer.variance_weighted_gaussian_kernel!-Tuple{Any}","page":"Home","title":"SMLMBoxer.variance_weighted_gaussian_kernel!","text":"variance_weighted_gaussian_kernel!(output, input, variance, sigma, winsize)\n\nKernelAbstractions kernel for variance-weighted Gaussian convolution. Implements SMITE-style inverse variance weighting.\n\nThis follows the same KernelAbstractions pattern used in GaussMLE.jl (kernel-abstract branch) for seamless CPU/GPU execution and consistent API across JuliaSMLM packages.\n\nArguments\n\noutput: Output array (nrows, ncols)\ninput: Input array (nrows, ncols)\nvariance: Variance map (nrows, ncols)\nsigma: Gaussian sigma\nwinsize: Window size (pixels)\n\nNote\n\nSame kernel code runs on CPU (via CPU() backend) or GPU (via CUDABackend()). Backend is selected automatically based on use_gpu parameter.\n\n\n\n\n\n","category":"method"}]
}
